#include <tsn/common/Context.h>
#include <tsn/common/Module.h>
#include <tsn/common/Config.h>
#include <tsn/compiler/TemplateContext.h>
#include <tsn/compiler/Parser.h>
#include <tsn/ffi/DataTypeRegistry.hpp>
#include <tsn/ffi/FunctionRegistry.hpp>
#include <tsn/ffi/Function.h>
#include <tsn/bind/bind_type.hpp>
#include <stdarg.h>

namespace tsn {
    bool Context::generateTypeDefs(const utils::String& fileName) {
        utils::String out;
        u32 indent = 0;
        auto ln = [&out, &indent](const char* fmt, ...) {
            if (!fmt || fmt[0] == 0) {
                out += "\n";
                return;
            }

            char buf[512];
            char* dst = buf;
            i32 maxLen = 512;

            for (u32 i = 0;i < indent;i++) {
                for (u32 s = 0;s < 4;s++) *(dst++) = ' ';
                maxLen -= 4;
            }

            va_list l;
            va_start(l, fmt);
            dst += vsnprintf(dst, maxLen, fmt, l);
            va_end(l);

            (*dst++) = '\n';
            (*dst++) = 0;

            out += buf;
        };

        auto func = [&ln](ffi::Function* fn, bool isGlobal, const char* nameOverride = nullptr) {
            ffi::FunctionType* sig = fn->getSignature();
            utils::String decl = utils::String::Format("%s function %s", isGlobal ? "declare" : "export", nameOverride ? nameOverride : fn->getName().c_str());

            if (fn->getFlags().is_template) {
                ffi::TemplateFunction* tfn = (ffi::TemplateFunction*)fn;

                decl += '<';

                compiler::ParseNode* n = tfn->getTemplateData()->getAST()->template_parameters;
                bool started = false;
                while (n) {
                    if (started) decl += ", ";
                    started = true;
                    decl += n->str();
                    n = n->next;
                }

                decl += '>';
            }

            decl += '(';

            const utils::Array<ffi::function_argument>& args = sig->getArguments();
            bool started = false;
            for (u32 a = 0;a < args.size();a++) {
                if (args[a].isImplicit()) continue;
                if (started) decl += ", ";
                started = true;

                decl += utils::String::Format("param_%d: %s", a, args[a].dataType->getName().c_str());
            }

            decl += "): ";

            if (sig->getReturnType()) decl += sig->getReturnType()->getName();
            else decl += "void";

            decl += ';';

            ln(decl.c_str());
        };
        auto meth = [&ln](ffi::Function* fn, const char* nameOverride = nullptr) {
            ffi::FunctionType* sig = fn->getSignature();
            utils::String decl = utils::String::Format("%s", nameOverride ? nameOverride : fn->getName().c_str());
            
            if (!sig->getThisType()) {
                decl = "static " + decl;
            }

            if (!nameOverride && fn->getName().firstIndexOf("operator") == 0) {
                decl = "// " + decl;
            }

            if (fn->getFlags().is_template) {
                ffi::TemplateFunction* tfn = (ffi::TemplateFunction*)fn;

                decl += '<';

                compiler::ParseNode* n = tfn->getTemplateData()->getAST()->template_parameters;
                bool started = false;
                while (n) {
                    if (started) decl += ", ";
                    started = true;
                    decl += n->str();
                    n = n->next;
                }

                decl += '>';
            }

            decl += '(';

            const utils::Array<ffi::function_argument>& args = sig->getArguments();
            bool started = false;
            for (u32 a = 0;a < args.size();a++) {
                if (args[a].isImplicit()) continue;
                if (started) decl += ", ";
                started = true;

                decl += utils::String::Format("param_%d: %s", a, args[a].dataType->getName().c_str());
            }

            decl += ")";

            if (fn->getName() == "constructor" && !nameOverride) decl += ';';
            else {
                decl += ": ";

                if (sig->getReturnType()) decl += sig->getReturnType()->getName();
                else decl += "void";

                decl += ';';
            }
            
            ln(decl.c_str());
        };


        ln("/* This file is automatically generated */");
        ln("");

        for (u32 i = 0;i < m_modules.size();i++) {
            if (i > 0) ln("");
            bool isGlobal = m_modules[i]->getName() == "global";

            auto types = m_types->allTypes().filter([i, isGlobal, this](ffi::DataType* tp) {
                if (!tp) return false;
                if (isGlobal) {
                    if (tp->getSource() != nullptr && tp->getSource() != m_modules[i]) return false;
                } else {
                    if (tp->getSource() != m_modules[i]) return false;
                }
                return true;
            });
            auto funcs = m_funcs->allFunctions().filter([i, isGlobal, this](ffi::Function* fn) {
                if (!fn) return false;
                if (fn->getName().size() == 0 || fn->getName()[0] == '$') return false;
                return fn->getSource() == (isGlobal ? nullptr : m_modules[i]) && !fn->getOwner();
            });

            if (!isGlobal) {
                ln("declare module '%s' {", m_modules[i]->getName().c_str());
                indent++;
            }

            u32 slotCount = m_modules[i]->getDataSlotCount();
            for (u32 s = 0;s < slotCount;s++) {
                auto& si = m_modules[i]->getDataInfo(s);
                if (si.access == access_modifier::private_access) continue;

                ln("%s const %s: %s;", isGlobal ? "declare" : "export", si.name.c_str(), si.type->getName().c_str());
            }

            if (slotCount > 0 && funcs.size() > 0) ln("");

            for (u32 f = 0;f < funcs.size();f++) {
                ffi::Function* fn = funcs[f];
                if (fn->getAccessModifier() == access_modifier::private_access) continue;

                func(fn, isGlobal);
            }

            if (funcs.size() > 0 && types.size() > 0) ln("");

            bool lastWasAlias = false;

            for (u32 t = 0;t < types.size();t++) {
                ffi::DataType* tp = types[t];
                if (tp->getAccessModifier() == access_modifier::private_access) continue;
                if (tp->getTemplateBase()) continue;
                
                auto& info = tp->getInfo();

                switch (tp->getInstanceType()) {
                    case ffi::data_type_instance::dti_plain: {
                        if (info.is_primitive) {
                            const char* aliasOf = "error-tp";
                            if (tp->getName() == "boolean") continue;
                            else if (info.is_integral || info.is_floating_point) aliasOf = "number & {}";
                            else if (info.size == 0) continue;

                            if (t > 0 && !lastWasAlias) ln("");
                            lastWasAlias = true;
                            ln("%s type %s = %s;", isGlobal ? "declare" : "export", tp->getName().c_str(), aliasOf);
                            break;
                        } else if (tp->getName()[0] == '$') continue;
                        else if (tp->getName() == "null_t") {
                            if (t > 0 && !lastWasAlias) ln("");
                            lastWasAlias = true;
                            ln("%s type null_t = null;", isGlobal ? "declare" : "export");
                            break;
                        } else if (tp->getName() == "string") continue;
                        
                        if (t > 0) ln("");
                        lastWasAlias = false;
                        ln("%s class %s {", isGlobal ? "declare" : "export", tp->getName().c_str());
                        indent++;

                        auto& props = tp->getProperties();
                        for (u32 p = 0;p < props.size();p++) {
                            if (props[p].access == access_modifier::private_access) continue;

                            if (props[p].getter) {
                                meth(props[p].getter, utils::String::Format("get %s", props[p].name.c_str()).c_str());
                                if (props[p].setter) {
                                    meth(props[p].setter, utils::String::Format("set %s", props[p].name.c_str()).c_str());
                                }
                            } else {
                                ln(
                                    "%s%s%s%s: %s;",
                                    props[p].flags.can_read == 1 ? "public " : "private ",
                                    props[p].flags.can_write == 0 ? "readonly " : "",
                                    props[p].flags.is_static == 1 ? "static " : "",
                                    props[p].name.c_str(),
                                    props[p].type->getName().c_str()
                                );
                            }
                        }

                        auto& methods = tp->getMethods();
                        if (props.size() > 0 && methods.size() > 0) ln("");

                        for (u32 m = 0;m < methods.size();m++) {
                            if (methods[m]->getAccessModifier() == access_modifier::private_access) continue;
                            meth(methods[m]);
                        }

                        indent--;
                        ln("}");
                        break;
                    }
                    case ffi::data_type_instance::dti_function: break;
                    case ffi::data_type_instance::dti_template: break;
                    case ffi::data_type_instance::dti_alias: {
                        ffi::AliasType* a = (ffi::AliasType*)tp;
                        if (t > 0) ln("");
                        ln("%s type %s = %s;", isGlobal ? "declare" : "export", tp->getName().c_str(), a->getRefType()->getName().c_str());
                        break;
                    }
                    case ffi::data_type_instance::dti_class: {
                        ffi::ClassType* c = (ffi::ClassType*)tp;
                        utils::String decl = utils::String::Format("%s class %s ", isGlobal ? "declare" : "export", tp->getName().c_str());

                        if (t > 0) ln("");
                        ln(decl.c_str());
                        indent++;

                        auto& props = tp->getProperties();
                        for (u32 p = 0;p < props.size();p++) {
                            if (props[p].access == access_modifier::private_access) continue;

                            if (props[p].getter) {
                                meth(props[p].getter, utils::String::Format("get %s", props[p].name.c_str()).c_str());
                                if (props[p].setter) {
                                    meth(props[p].setter, utils::String::Format("set %s", props[p].name.c_str()).c_str());
                                }
                            } else {
                                ln(
                                    "%s%s%s%s: %s;",
                                    props[p].flags.can_read == 1 ? "public " : "private ",
                                    props[p].flags.can_write == 0 ? "readonly " : "",
                                    props[p].flags.is_static == 1 ? "static " : "",
                                    props[p].name.c_str(),
                                    props[p].type->getName().c_str()
                                );
                            }
                        }

                        if (props.size() > 0) ln("");

                        auto& methods = tp->getMethods();
                        for (u32 m = 0;m < methods.size();m++) {
                            if (methods[m]->getAccessModifier() == access_modifier::private_access) continue;
                            meth(methods[m]);
                        }

                        indent--;
                        ln("}");
                        break;
                    }
                }
            }

            if (!isGlobal) {
                indent--;
                ln("}");
            }
        }

        ln("");

        ln("declare class Pointer<DestType> {");
        indent++;

        ln("constructor();");
        ln("constructor(pointsTo: null_t);");
        ln("constructor(cloneOf: Pointer<DestType>);");
        ln("constructor(pointsTo: DestType);");
        ln("");
        ln("// operator=(pointTo: null_t): void;");
        ln("// operator=(cloneFrom: Pointer<DestType>): void;");
        ln("// operator=(pointTo: DestType): void;");
        ln("// operator==(nullVal: null_t): void;");
        ln("// operator!=(nullVal: null_t): void;");
        ln("// operator boolean(): boolean;");
        ln("");
        ln("release(): void;");
        ln("get references(): u32;");

        indent--;
        ln("}");

        ln("");
        
        ln("declare class Array<ElementType> {");
        indent++;

        ln("constructor();");
        ln("constructor(initialCapacity: u32);");
        ln("constructor(copyFrom: Array<ElementType>);");
        ln("");
        ln("// operator=(cloneFrom: Array<ElementType>): void;");
        ln("// operator[](index: u32) : ElementType;");
        ln("");
        ln("clear(): void;");
        ln("reserve(count: u32): void;");
        ln("push(element: ElementType): void;");
        ln("get length(): u32;");
        ln("get capacity(): u32;");

        indent--;
        ln("}");

        std::string path = m_cfg->workspaceRoot + "/" + fileName.c_str();
        FILE* fp = nullptr;
        fopen_s(&fp, path.c_str(), "w");
        if (!fp) return false;

        if (fwrite(out.c_str(), 1, out.size(), fp) != out.size()) {
            fclose(fp);
            return false;
        }

        fclose(fp);

        return true;
    }
}